<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docs/README_STEP_3.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/README_STEP_3.md" />
              <option name="originalContent" value="# Passo 3 - Entity e Repository (Mapeamento Java ↔ Banco)&#10;&#10;## O que vamos fazer&#10;Vamos criar a classe `NinjaEntity` que representa um ninja em Java e conectá-la com a tabela do banco de dados.&#10;&#10;## 1) Criando a NinjaEntity&#10;&#10;A **Entity** é uma classe Java que representa uma tabela do banco de dados.&#10;&#10;Crie o arquivo `src/main/java/br/org/soujava/bsb/api/domain/entity/NinjaEntity.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.entity;&#10;&#10;import jakarta.persistence.*;&#10;import java.time.LocalDate;&#10;&#10;@Entity&#10;@Table(name = &quot;NINJA&quot;)&#10;public class NinjaEntity {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    @Column(name = &quot;ID_NINJA&quot;)&#10;    private Integer id;&#10;&#10;    @Column(name = &quot;NOME&quot;, nullable = false, length = 100)&#10;    private String nome;&#10;&#10;    @Column(name = &quot;VILA&quot;, nullable = false, length = 50)&#10;    private String vila;&#10;&#10;    @Column(name = &quot;CLA&quot;, length = 50)&#10;    private String cla;&#10;&#10;    @Column(name = &quot;RANK&quot;, nullable = false, length = 20)&#10;    private String rank;&#10;&#10;    @Column(name = &quot;CHAKRA_TIPO&quot;, nullable = false, length = 30)&#10;    private String chakraTipo;&#10;&#10;    @Column(name = &quot;ESPECIALIDADE&quot;, length = 50)&#10;    private String especialidade;&#10;&#10;    @Column(name = &quot;KEKKEI_GENKAI&quot;, length = 50)&#10;    private String kekkeiGenkai;&#10;&#10;    @Column(name = &quot;STATUS&quot;, length = 20)&#10;    private String status;&#10;&#10;    @Column(name = &quot;NIVEL_FORCA&quot;)&#10;    private Integer nivelForca;&#10;&#10;    @Column(name = &quot;DATA_REGISTRO&quot;)&#10;    private LocalDate dataRegistro;&#10;&#10;    // Construtor vazio (obrigatório para JPA)&#10;    public NinjaEntity() {}&#10;&#10;    // Getters e Setters&#10;    public Integer getId() { return id; }&#10;    public void setId(Integer id) { this.id = id; }&#10;&#10;    public String getNome() { return nome; }&#10;    public void setNome(String nome) { this.nome = nome; }&#10;&#10;    public String getVila() { return vila; }&#10;    public void setVila(String vila) { this.vila = vila; }&#10;&#10;    public String getCla() { return cla; }&#10;    public void setCla(String cla) { this.cla = cla; }&#10;&#10;    public String getRank() { return rank; }&#10;    public void setRank(String rank) { this.rank = rank; }&#10;&#10;    public String getChakraTipo() { return chakraTipo; }&#10;    public void setChakraTipo(String chakraTipo) { this.chakraTipo = chakraTipo; }&#10;&#10;    public String getEspecialidade() { return especialidade; }&#10;    public void setEspecialidade(String especialidade) { this.especialidade = especialidade; }&#10;&#10;    public String getKekkeiGenkai() { return kekkeiGenkai; }&#10;    public void setKekkeiGenkai(String kekkeiGenkai) { this.kekkeiGenkai = kekkeiGenkai; }&#10;&#10;    public String getStatus() { return status; }&#10;    public void setStatus(String status) { this.status = status; }&#10;&#10;    public Integer getNivelForca() { return nivelForca; }&#10;    public void setNivelForca(Integer nivelForca) { this.nivelForca = nivelForca; }&#10;&#10;    public LocalDate getDataRegistro() { return dataRegistro; }&#10;    public void setDataRegistro(LocalDate dataRegistro) { this.dataRegistro = dataRegistro; }&#10;}&#10;```&#10;&#10;**Entendendo as anotações:**&#10;- `@Entity` - marca a classe como uma tabela do banco&#10;- `@Table(name = &quot;NINJA&quot;)` - nome da tabela no banco&#10;- `@Id` - marca o campo como chave primária&#10;- `@GeneratedValue` - valor gerado automaticamente (AUTO_INCREMENT)&#10;- `@Column` - mapeia campo Java para coluna do banco&#10;&#10;## 2) Criando o Repository&#10;&#10;O **Repository** é uma interface que nos permite fazer operações no banco (buscar, salvar, deletar).&#10;&#10;Crie o arquivo `src/main/java/br/org/soujava/bsb/api/domain/repository/NinjaRepository.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.repository;&#10;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;@Repository&#10;public interface NinjaRepository extends JpaRepository&lt;NinjaEntity, Integer&gt; {&#10;    &#10;    // Métodos automáticos já disponíveis:&#10;    // - findAll() - busca todos os ninjas&#10;    // - findById(id) - busca por ID&#10;    // - save(ninja) - salva ou atualiza&#10;    // - deleteById(id) - deleta por ID&#10;    &#10;    // Você pode criar métodos personalizados aqui se precisar&#10;}&#10;```&#10;&#10;**O que o Repository nos dá:**&#10;- `findAll()` - busca todos os ninjas&#10;- `findById(id)` - busca ninja por ID&#10;- `save(ninja)` - salva ou atualiza um ninja&#10;- `deleteById(id)` - deleta ninja por ID&#10;- E muito mais automaticamente!&#10;&#10;## 3) Testando se funcionou com NinjaRepositoryTest&#10;&#10;Vamos criar testes para validar se nossa Entity e Repository estão funcionando corretamente. Os testes são fundamentais para garantir que nosso código funciona como esperado.&#10;&#10;### 3.1) Por que testar?&#10;&#10;**Testes automatizados nos ajudam a:**&#10;- ✅ Verificar se o código funciona corretamente&#10;- ✅ Detectar problemas antes de colocar em produção&#10;- ✅ Ter confiança para fazer mudanças&#10;- ✅ Documentar como o código deve funcionar&#10;&#10;### 3.2) Criando a classe de teste&#10;&#10;Crie o arquivo `src/test/java/br/org/soujava/bsb/api/domain/repository/NinjaRepositoryTest.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.repository;&#10;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;&#10;import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;&#10;import org.springframework.test.context.ActiveProfiles;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.assertj.core.api.Assertions.assertThat;&#10;&#10;@DataJpaTest&#10;@ActiveProfiles(&quot;test&quot;)&#10;@DisplayName(&quot;Ninja Repository&quot;)&#10;class NinjaRepositoryTest {&#10;&#10;    @Autowired&#10;    private NinjaRepository ninjaRepository;&#10;&#10;    @Autowired&#10;    private TestEntityManager entityManager;&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve carregar os dados iniciais do data.sql&quot;)&#10;    void deveCarregarDadosIniciais() {&#10;        // Given: dados já carregados pelo data.sql&#10;&#10;        // When: buscar todos os ninjas&#10;        List&lt;NinjaEntity&gt; ninjas = ninjaRepository.findAll();&#10;&#10;        // Then: deve ter os 4 ninjas iniciais&#10;        assertThat(ninjas).hasSize(4);&#10;        assertThat(ninjas)&#10;            .extracting(NinjaEntity::getNome)&#10;            .containsExactlyInAnyOrder(&#10;                &quot;Naruto Uzumaki&quot;,&#10;                &quot;Sasuke Uchiha&quot;, &#10;                &quot;Sakura Haruno&quot;,&#10;                &quot;Gaara&quot;&#10;            );&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve buscar ninja por ID existente&quot;)&#10;    void deveBuscarNinjaPorIdExistente() {&#10;        // Given: ID de um ninja existente (Naruto é geralmente ID 1)&#10;        Integer idNaruto = 1;&#10;&#10;        // When: buscar por ID&#10;        Optional&lt;NinjaEntity&gt; ninjaEncontrado = ninjaRepository.findById(idNaruto);&#10;&#10;        // Then: deve encontrar o ninja&#10;        assertThat(ninjaEncontrado).isPresent();&#10;        assertThat(ninjaEncontrado.get().getNome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;        assertThat(ninjaEncontrado.get().getVila()).isEqualTo(&quot;Konoha&quot;);&#10;        assertThat(ninjaEncontrado.get().getRank()).isEqualTo(&quot;Hokage&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar vazio ao buscar ninja por ID inexistente&quot;)&#10;    void deveRetornarVazioParaIdInexistente() {&#10;        // Given: ID que não existe&#10;        Integer idInexistente = 999;&#10;&#10;        // When: buscar por ID inexistente&#10;        Optional&lt;NinjaEntity&gt; ninja = ninjaRepository.findById(idInexistente);&#10;&#10;        // Then: deve retornar Optional vazio&#10;        assertThat(ninja).isEmpty();&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve salvar novo ninja com sucesso&quot;)&#10;    void deveSalvarNovoNinja() {&#10;        // Given: novo ninja para salvar&#10;        NinjaEntity novoNinja = new NinjaEntity();&#10;        novoNinja.setNome(&quot;Kakashi Hatake&quot;);&#10;        novoNinja.setVila(&quot;Konoha&quot;);&#10;        novoNinja.setCla(&quot;Hatake&quot;);&#10;        novoNinja.setRank(&quot;Jounin&quot;);&#10;        novoNinja.setChakraTipo(&quot;Raio&quot;);&#10;        novoNinja.setEspecialidade(&quot;Ninjutsu&quot;);&#10;        novoNinja.setKekkeiGenkai(&quot;Sharingan&quot;);&#10;        novoNinja.setStatus(&quot;Ativo&quot;);&#10;        novoNinja.setNivelForca(92);&#10;        novoNinja.setDataRegistro(LocalDate.now());&#10;&#10;        // When: salvar ninja&#10;        NinjaEntity ninjaSalvo = ninjaRepository.save(novoNinja);&#10;&#10;        // Then: deve salvar com ID gerado&#10;        assertThat(ninjaSalvo.getId()).isNotNull();&#10;        assertThat(ninjaSalvo.getNome()).isEqualTo(&quot;Kakashi Hatake&quot;);&#10;&#10;        // Verificar se foi realmente persistido&#10;        Optional&lt;NinjaEntity&gt; ninjaVerificacao = ninjaRepository.findById(ninjaSalvo.getId());&#10;        assertThat(ninjaVerificacao).isPresent();&#10;        assertThat(ninjaVerificacao.get().getNome()).isEqualTo(&quot;Kakashi Hatake&quot;);&#10;    }&#10;}&#10;```&#10;&#10;### 3.3) Entendendo as anotações de teste&#10;&#10;**@DataJpaTest**&#10;- Configura um teste focado apenas na camada JPA&#10;- Cria um banco de dados em memória para o teste&#10;- Carrega apenas os componentes relacionados ao JPA&#10;&#10;**@ActiveProfiles(&quot;test&quot;)**  &#10;- Ativa o profile &quot;test&quot; &#10;- Permite configurações específicas para testes&#10;&#10;**@DisplayName(&quot;...&quot;)**&#10;- Nome amigável para o teste&#10;- Aparece nos relatórios de teste&#10;&#10;**@Test**&#10;- Marca o método como um teste&#10;- Será executado pelo framework de testes&#10;&#10;**@Autowired**&#10;- Injeta automaticamente as dependências&#10;- Spring cria e injeta o NinjaRepository&#10;&#10;### 3.4) Padrão Given-When-Then&#10;&#10;Nossos testes seguem o padrão **Given-When-Then**:&#10;&#10;```java&#10;// Given: Preparação - o que já existe&#10;Integer idNaruto = 1;&#10;&#10;// When: Ação - o que vamos testar  &#10;Optional&lt;NinjaEntity&gt; ninja = ninjaRepository.findById(idNaruto);&#10;&#10;// Then: Verificação - o que esperamos&#10;assertThat(ninja).isPresent();&#10;```&#10;&#10;**Given** = Contexto (o que já temos)&#10;**When** = Ação (o que fazemos)  &#10;**Then** = Resultado esperado (o que deve acontecer)&#10;&#10;### 3.5) Entendendo as asserções (AssertJ)&#10;&#10;**assertThat()** - Início de uma verificação&#10;**isPresent()** - Verifica se Optional não está vazio&#10;**isEmpty()** - Verifica se Optional está vazio&#10;**hasSize(4)** - Verifica se lista tem 4 elementos&#10;**isEqualTo(&quot;Naruto&quot;)** - Verifica se valor é igual&#10;**isNotNull()** - Verifica se não é nulo&#10;&#10;### 3.6) Executando os testes&#10;&#10;**No terminal:**&#10;```bash&#10;# Executa todos os testes&#10;./mvnw test&#10;&#10;# Executa apenas os testes do Repository&#10;./mvnw test -Dtest=NinjaRepositoryTest&#10;```&#10;&#10;**Na IDE (IntelliJ/Eclipse):**&#10;- Clique com botão direito na classe de teste&#10;- Selecione &quot;Run NinjaRepositoryTest&quot;&#10;- Ou clique no ícone de &quot;play&quot; ao lado da classe&#10;&#10;### 3.7) O que cada teste valida&#10;&#10;1. **deveCarregarDadosIniciais()** &#10;   - Verifica se o data.sql foi carregado&#10;   - Confirma que temos 4 ninjas na base&#10;&#10;2. **deveBuscarNinjaPorIdExistente()**&#10;   - Testa se conseguimos buscar um ninja pelo ID&#10;   - Valida se os dados estão corretos&#10;&#10;3. **deveRetornarVazioParaIdInexistente()**&#10;   - Testa o comportamento quando ID não existe&#10;   - Deve retornar Optional.empty()&#10;&#10;4. **deveSalvarNovoNinja()**&#10;   - Testa se conseguimos salvar um novo ninja&#10;   - Verifica se o ID é gerado automaticamente&#10;   - Confirma que foi persistido no banco&#10;&#10;### 3.8) Resultado esperado&#10;&#10;Quando você executar os testes, deve ver algo como:&#10;```&#10;[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0&#10;[INFO] BUILD SUCCESS&#10;```&#10;&#10;Se algum teste falhar, você verá uma mensagem detalhada explicando o que deu errado.&#10;&#10;## Próximo passo&#10;Agora vamos criar os DTOs (objetos para receber/enviar dados pela API) e o Mapper. **[STEP 4 — DTOs](README_STEP_4.md)**&#10;" />
              <option name="updatedContent" value="# Passo 3 - Entity e Repository (Mapeamento Java ↔ Banco)&#10;&#10;## O que vamos fazer&#10;Vamos criar a classe `NinjaEntity` que representa um ninja em Java e conectá-la com a tabela do banco de dados.&#10;&#10;## 1) Criando a NinjaEntity&#10;&#10;A **Entity** é uma classe Java que representa uma tabela do banco de dados.&#10;&#10;Crie o arquivo `src/main/java/br/org/soujava/bsb/api/domain/entity/NinjaEntity.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.entity;&#10;&#10;import jakarta.persistence.*;&#10;import java.time.LocalDate;&#10;import org.hibernate.annotations.ColumnDefault;&#10;&#10;@Entity&#10;@Table(name = &quot;NINJA&quot;)&#10;public class NinjaEntity {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    @Column(name = &quot;ID_NINJA&quot;, nullable = false)&#10;    private Integer id;&#10;&#10;    @Column(name = &quot;NOME&quot;, nullable = false, length = 100)&#10;    private String nome;&#10;&#10;    @Column(name = &quot;VILA&quot;, nullable = false, length = 50)&#10;    private String vila;&#10;&#10;    @Column(name = &quot;CLA&quot;, length = 50)&#10;    private String cla;&#10;&#10;    @Column(name = &quot;RANK&quot;, nullable = false, length = 20)&#10;    private String rank;&#10;&#10;    @Column(name = &quot;CHAKRA_TIPO&quot;, nullable = false, length = 30)&#10;    private String chakraTipo;&#10;&#10;    @Column(name = &quot;ESPECIALIDADE&quot;, length = 50)&#10;    private String especialidade;&#10;&#10;    @Column(name = &quot;KEKKEI_GENKAI&quot;, length = 50)&#10;    private String kekkeiGenkai;&#10;&#10;    @ColumnDefault(&quot;'Ativo'&quot;)&#10;    @Column(name = &quot;STATUS&quot;, length = 20)&#10;    private String status;&#10;&#10;    @Column(name = &quot;NIVEL_FORCA&quot;)&#10;    private Integer nivelForca;&#10;&#10;    @ColumnDefault(&quot;CURRENT_DATE&quot;)&#10;    @Column(name = &quot;DATA_REGISTRO&quot;)&#10;    private LocalDate dataRegistro;&#10;&#10;    // Construtor vazio (obrigatório para JPA)&#10;    public NinjaEntity() {}&#10;&#10;    // Getters e Setters&#10;    public Integer getId() { return id; }&#10;    public void setId(Integer id) { this.id = id; }&#10;&#10;    public String getNome() { return nome; }&#10;    public void setNome(String nome) { this.nome = nome; }&#10;&#10;    public String getVila() { return vila; }&#10;    public void setVila(String vila) { this.vila = vila; }&#10;&#10;    public String getCla() { return cla; }&#10;    public void setCla(String cla) { this.cla = cla; }&#10;&#10;    public String getRank() { return rank; }&#10;    public void setRank(String rank) { this.rank = rank; }&#10;&#10;    public String getChakraTipo() { return chakraTipo; }&#10;    public void setChakraTipo(String chakraTipo) { this.chakraTipo = chakraTipo; }&#10;&#10;    public String getEspecialidade() { return especialidade; }&#10;    public void setEspecialidade(String especialidade) { this.especialidade = especialidade; }&#10;&#10;    public String getKekkeiGenkai() { return kekkeiGenkai; }&#10;    public void setKekkeiGenkai(String kekkeiGenkai) { this.kekkeiGenkai = kekkeiGenkai; }&#10;&#10;    public String getStatus() { return status; }&#10;    public void setStatus(String status) { this.status = status; }&#10;&#10;    public Integer getNivelForca() { return nivelForca; }&#10;    public void setNivelForca(Integer nivelForca) { this.nivelForca = nivelForca; }&#10;&#10;    public LocalDate getDataRegistro() { return dataRegistro; }&#10;    public void setDataRegistro(LocalDate dataRegistro) { this.dataRegistro = dataRegistro; }&#10;}&#10;```&#10;&#10;**Entendendo as anotações:**&#10;- `@Entity` - marca a classe como uma tabela do banco&#10;- `@Table(name = &quot;NINJA&quot;)` - nome da tabela no banco&#10;- `@Id` - marca o campo como chave primária&#10;- `@GeneratedValue` - valor gerado automaticamente (AUTO_INCREMENT)&#10;- `@Column` - mapeia campo Java para coluna do banco&#10;&#10;## 2) Criando o Repository&#10;&#10;O **Repository** é uma interface que nos permite fazer operações no banco (buscar, salvar, deletar).&#10;&#10;Crie o arquivo `src/main/java/br/org/soujava/bsb/api/domain/repository/NinjaRepository.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.repository;&#10;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;@Repository&#10;public interface NinjaRepository extends JpaRepository&lt;NinjaEntity, Integer&gt; {&#10;    &#10;    // Métodos automáticos já disponíveis:&#10;    // - findAll() - busca todos os ninjas&#10;    // - findById(id) - busca por ID&#10;    // - save(ninja) - salva ou atualiza&#10;    // - deleteById(id) - deleta por ID&#10;    &#10;    // Você pode criar métodos personalizados aqui se precisar&#10;}&#10;```&#10;&#10;**O que o Repository nos dá:**&#10;- `findAll()` - busca todos os ninjas&#10;- `findById(id)` - busca ninja por ID&#10;- `save(ninja)` - salva ou atualiza um ninja&#10;- `deleteById(id)` - deleta ninja por ID&#10;- E muito mais automaticamente!&#10;&#10;## 3) Testando se funcionou com NinjaRepositoryTest&#10;&#10;Vamos criar testes para validar se nossa Entity e Repository estão funcionando corretamente. Os testes são fundamentais para garantir que nosso código funciona como esperado.&#10;&#10;### 3.1) Por que testar?&#10;&#10;**Testes automatizados nos ajudam a:**&#10;- ✅ Verificar se o código funciona corretamente&#10;- ✅ Detectar problemas antes de colocar em produção&#10;- ✅ Ter confiança para fazer mudanças&#10;- ✅ Documentar como o código deve funcionar&#10;&#10;### 3.2) Criando a classe de teste&#10;&#10;Crie o arquivo `src/test/java/br/org/soujava/bsb/api/domain/repository/NinjaRepositoryTest.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.repository;&#10;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;&#10;import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;&#10;import org.springframework.test.context.ActiveProfiles;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.assertj.core.api.Assertions.assertThat;&#10;&#10;@DataJpaTest&#10;@ActiveProfiles(&quot;test&quot;)&#10;@DisplayName(&quot;Ninja Repository&quot;)&#10;class NinjaRepositoryTest {&#10;&#10;    @Autowired&#10;    private NinjaRepository ninjaRepository;&#10;&#10;    @Autowired&#10;    private TestEntityManager entityManager;&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve carregar os dados iniciais do data.sql&quot;)&#10;    void deveCarregarDadosIniciais() {&#10;        // Given: dados já carregados pelo data.sql&#10;&#10;        // When: buscar todos os ninjas&#10;        List&lt;NinjaEntity&gt; ninjas = ninjaRepository.findAll();&#10;&#10;        // Then: deve ter os 4 ninjas iniciais&#10;        assertThat(ninjas).hasSize(4);&#10;        assertThat(ninjas)&#10;            .extracting(NinjaEntity::getNome)&#10;            .containsExactlyInAnyOrder(&#10;                &quot;Naruto Uzumaki&quot;,&#10;                &quot;Sasuke Uchiha&quot;, &#10;                &quot;Sakura Haruno&quot;,&#10;                &quot;Gaara&quot;&#10;            );&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve buscar ninja por ID existente&quot;)&#10;    void deveBuscarNinjaPorIdExistente() {&#10;        // Given: ID de um ninja existente (Naruto é geralmente ID 1)&#10;        Integer idNaruto = 1;&#10;&#10;        // When: buscar por ID&#10;        Optional&lt;NinjaEntity&gt; ninjaEncontrado = ninjaRepository.findById(idNaruto);&#10;&#10;        // Then: deve encontrar o ninja&#10;        assertThat(ninjaEncontrado).isPresent();&#10;        assertThat(ninjaEncontrado.get().getNome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;        assertThat(ninjaEncontrado.get().getVila()).isEqualTo(&quot;Konoha&quot;);&#10;        assertThat(ninjaEncontrado.get().getRank()).isEqualTo(&quot;Hokage&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar vazio ao buscar ninja por ID inexistente&quot;)&#10;    void deveRetornarVazioParaIdInexistente() {&#10;        // Given: ID que não existe&#10;        Integer idInexistente = 999;&#10;&#10;        // When: buscar por ID inexistente&#10;        Optional&lt;NinjaEntity&gt; ninja = ninjaRepository.findById(idInexistente);&#10;&#10;        // Then: deve retornar Optional vazio&#10;        assertThat(ninja).isEmpty();&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve salvar novo ninja com sucesso&quot;)&#10;    void deveSalvarNovoNinja() {&#10;        // Given: novo ninja para salvar&#10;        NinjaEntity novoNinja = new NinjaEntity();&#10;        novoNinja.setNome(&quot;Kakashi Hatake&quot;);&#10;        novoNinja.setVila(&quot;Konoha&quot;);&#10;        novoNinja.setCla(&quot;Hatake&quot;);&#10;        novoNinja.setRank(&quot;Jounin&quot;);&#10;        novoNinja.setChakraTipo(&quot;Raio&quot;);&#10;        novoNinja.setEspecialidade(&quot;Ninjutsu&quot;);&#10;        novoNinja.setKekkeiGenkai(&quot;Sharingan&quot;);&#10;        novoNinja.setStatus(&quot;Ativo&quot;);&#10;        novoNinja.setNivelForca(92);&#10;        novoNinja.setDataRegistro(LocalDate.now());&#10;&#10;        // When: salvar ninja&#10;        NinjaEntity ninjaSalvo = ninjaRepository.save(novoNinja);&#10;&#10;        // Then: deve salvar com ID gerado&#10;        assertThat(ninjaSalvo.getId()).isNotNull();&#10;        assertThat(ninjaSalvo.getNome()).isEqualTo(&quot;Kakashi Hatake&quot;);&#10;&#10;        // Verificar se foi realmente persistido&#10;        Optional&lt;NinjaEntity&gt; ninjaVerificacao = ninjaRepository.findById(ninjaSalvo.getId());&#10;        assertThat(ninjaVerificacao).isPresent();&#10;        assertThat(ninjaVerificacao.get().getNome()).isEqualTo(&quot;Kakashi Hatake&quot;);&#10;    }&#10;}&#10;```&#10;&#10;### 3.3) Entendendo as anotações de teste&#10;&#10;**@DataJpaTest**&#10;- Configura um teste focado apenas na camada JPA&#10;- Cria um banco de dados em memória para o teste&#10;- Carrega apenas os componentes relacionados ao JPA&#10;&#10;**@ActiveProfiles(&quot;test&quot;)**  &#10;- Ativa o profile &quot;test&quot; &#10;- Permite configurações específicas para testes&#10;&#10;**@DisplayName(&quot;...&quot;)**&#10;- Nome amigável para o teste&#10;- Aparece nos relatórios de teste&#10;&#10;**@Test**&#10;- Marca o método como um teste&#10;- Será executado pelo framework de testes&#10;&#10;**@Autowired**&#10;- Injeta automaticamente as dependências&#10;- Spring cria e injeta o NinjaRepository&#10;&#10;### 3.4) Padrão Given-When-Then&#10;&#10;Nossos testes seguem o padrão **Given-When-Then**:&#10;&#10;```java&#10;// Given: Preparação - o que já existe&#10;Integer idNaruto = 1;&#10;&#10;// When: Ação - o que vamos testar  &#10;Optional&lt;NinjaEntity&gt; ninja = ninjaRepository.findById(idNaruto);&#10;&#10;// Then: Verificação - o que esperamos&#10;assertThat(ninja).isPresent();&#10;```&#10;&#10;**Given** = Contexto (o que já temos)&#10;**When** = Ação (o que fazemos)  &#10;**Then** = Resultado esperado (o que deve acontecer)&#10;&#10;### 3.5) Entendendo as asserções (AssertJ)&#10;&#10;**assertThat()** - Início de uma verificação&#10;**isPresent()** - Verifica se Optional não está vazio&#10;**isEmpty()** - Verifica se Optional está vazio&#10;**hasSize(4)** - Verifica se lista tem 4 elementos&#10;**isEqualTo(&quot;Naruto&quot;)** - Verifica se valor é igual&#10;**isNotNull()** - Verifica se não é nulo&#10;&#10;### 3.6) Executando os testes&#10;&#10;**No terminal:**&#10;```bash&#10;# Executa todos os testes&#10;./mvnw test&#10;&#10;# Executa apenas os testes do Repository&#10;./mvnw test -Dtest=NinjaRepositoryTest&#10;```&#10;&#10;**Na IDE (IntelliJ/Eclipse):**&#10;- Clique com botão direito na classe de teste&#10;- Selecione &quot;Run NinjaRepositoryTest&quot;&#10;- Ou clique no ícone de &quot;play&quot; ao lado da classe&#10;&#10;### 3.7) O que cada teste valida&#10;&#10;1. **deveCarregarDadosIniciais()** &#10;   - Verifica se o data.sql foi carregado&#10;   - Confirma que temos 4 ninjas na base&#10;&#10;2. **deveBuscarNinjaPorIdExistente()**&#10;   - Testa se conseguimos buscar um ninja pelo ID&#10;   - Valida se os dados estão corretos&#10;&#10;3. **deveRetornarVazioParaIdInexistente()**&#10;   - Testa o comportamento quando ID não existe&#10;   - Deve retornar Optional.empty()&#10;&#10;4. **deveSalvarNovoNinja()**&#10;   - Testa se conseguimos salvar um novo ninja&#10;   - Verifica se o ID é gerado automaticamente&#10;   - Confirma que foi persistido no banco&#10;&#10;### 3.8) Resultado esperado&#10;&#10;Quando você executar os testes, deve ver algo como:&#10;```&#10;[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0&#10;[INFO] BUILD SUCCESS&#10;```&#10;&#10;Se algum teste falhar, você verá uma mensagem detalhada explicando o que deu errado.&#10;&#10;## Próximo passo&#10;Agora vamos criar os DTOs (objetos para receber/enviar dados pela API) e o Mapper. **[STEP 4 — DTOs](README_STEP_4.md)**" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/README_STEP_4.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/README_STEP_4.md" />
              <option name="originalContent" value="# Passo 4 - DTOs e Mapper (Objetos para API)&#10;&#10;## O que vamos fazer&#10;Vamos criar os DTOs (objetos que trafegam na API), adicionar o MapStruct ao projeto e criar o Mapper (converte automaticamente entre diferentes objetos).&#10;&#10;## 1) O que são DTOs?&#10;&#10;**DTO** = Data Transfer Object (Objeto de Transferência de Dados)&#10;&#10;- São objetos simples que carregam dados entre camadas da aplicação&#10;- **Request**: dados que chegam na API (quando alguém envia dados)&#10;- **Response**: dados que saem da API (quando retornamos dados)&#10;- **Query**: filtros de busca&#10;&#10;**Por que usar DTOs?**&#10;- Separar o que vai na API do que fica no banco&#10;- Controlar exatamente quais campos aparecem&#10;- Validar dados de entrada&#10;- Evoluir a API sem afetar o banco de dados&#10;&#10;## 2) Adicionando dependências do MapStruct&#10;&#10;Antes de criar nossos DTOs e Mapper, precisamos adicionar as dependências do MapStruct no `pom.xml`.&#10;&#10;### 2.1) Por que usar MapStruct?&#10;&#10;**Sem MapStruct (conversão manual):**&#10;```java&#10;// Muito código repetitivo e propenso a erros&#10;public NinjaResponse toResponse(NinjaEntity entity) {&#10;    NinjaResponse response = new NinjaResponse();&#10;    response.setId(entity.getId());&#10;    response.setNome(entity.getNome());&#10;    response.setVila(entity.getVila());&#10;    response.setCla(entity.getCla());&#10;    response.setRank(entity.getRank());&#10;    // ... mais 6 campos para copiar manualmente&#10;    return response;&#10;}&#10;```&#10;&#10;**Com MapStruct (automático):**&#10;```java&#10;// Uma linha só! MapStruct gera todo código automaticamente&#10;NinjaResponse response = ninjaMapper.entityToResponse(entity);&#10;```&#10;&#10;**Vantagens do MapStruct:**&#10;- ✅ **Automático** - Gera código de conversão na compilação&#10;- ✅ **Rápido** - Mais rápido que reflexão&#10;- ✅ **Seguro** - Detecta erros em tempo de compilação&#10;- ✅ **Limpo** - Menos código para manter&#10;&#10;### 2.2) Adicionando no pom.xml&#10;&#10;Adicione essas dependências na seção `&lt;dependencies&gt;` do seu `pom.xml`:&#10;&#10;```xml&#10;&lt;!-- MapStruct --&gt;&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#10;    &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;&#10;    &lt;version&gt;1.6.3&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;&#10;&lt;!-- MapStruct Processor (para gerar código automaticamente) --&gt;&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#10;    &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;&#10;    &lt;version&gt;1.6.3&lt;/version&gt;&#10;    &lt;scope&gt;provided&lt;/scope&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;**Importante:** O `mapstruct-processor` é fundamental! Ele gera automaticamente as classes de implementação durante a compilação.&#10;&#10;## 3) Criando os DTOs&#10;&#10;### 3.1) NinjaRequest (para receber dados)&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/api/v1/request/NinjaRequest.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.api.v1.request;&#10;&#10;import com.fasterxml.jackson.annotation.JsonInclude;&#10;import com.fasterxml.jackson.databind.PropertyNamingStrategies;&#10;import com.fasterxml.jackson.databind.annotation.JsonNaming;&#10;import java.time.LocalDate;&#10;&#10;@JsonInclude(JsonInclude.Include.NON_NULL)&#10;@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)&#10;public record NinjaRequest(&#10;    String nome,&#10;    String vila,&#10;    String cla,&#10;    String rank,&#10;    String chakraTipo,&#10;    String especialidade,&#10;    String kekkeiGenkai,&#10;    String status,&#10;    Integer nivelForca,&#10;    LocalDate dataRegistro&#10;) {}&#10;```&#10;&#10;**Explicando as anotações:**&#10;- `@JsonInclude(NON_NULL)` - só inclui campos que não são nulos&#10;- `@JsonNaming(SnakeCaseStrategy.class)` - converte `chakraTipo` para `chakra_tipo` no JSON&#10;&#10;### 3.2) NinjaResponse (para enviar dados)&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/api/v1/response/NinjaResponse.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.api.v1.response;&#10;&#10;import com.fasterxml.jackson.annotation.JsonInclude;&#10;import com.fasterxml.jackson.databind.PropertyNamingStrategies;&#10;import com.fasterxml.jackson.databind.annotation.JsonNaming;&#10;import java.time.LocalDate;&#10;&#10;@JsonInclude(JsonInclude.Include.NON_NULL)&#10;@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)&#10;public record NinjaResponse(&#10;    Integer id,&#10;    String nome,&#10;    String vila,&#10;    String cla,&#10;    String rank,&#10;    String chakraTipo,&#10;    String especialidade,&#10;    String kekkeiGenkai,&#10;    String status,&#10;    Integer nivelForca,&#10;    LocalDate dataRegistro&#10;) {}&#10;```&#10;&#10;### 3.3) NinjaQueryRequest (para filtros)&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/api/v1/request/NinjaQueryRequest.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.api.v1.request;&#10;&#10;import com.fasterxml.jackson.annotation.JsonInclude;&#10;import com.fasterxml.jackson.databind.PropertyNamingStrategies;&#10;import com.fasterxml.jackson.databind.annotation.JsonNaming;&#10;&#10;@JsonInclude(JsonInclude.Include.NON_NULL)&#10;@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)&#10;public record NinjaQueryRequest(&#10;    String nome,&#10;    String vila,&#10;    String rank,&#10;    String chakraTipo,&#10;    String status&#10;) {}&#10;```&#10;&#10;## 4) Criando o Mapper&#10;&#10;O **Mapper** converte automaticamente entre objetos diferentes. Usamos o MapStruct para isso.&#10;&#10;### 4.1) Por que usar o padrão Mapper?&#10;&#10;**Separação de responsabilidades:**&#10;- **Entity** - Representa dados no banco&#10;- **DTO** - Representa dados na API&#10;- **Mapper** - Faz a ponte entre Entity e DTO&#10;&#10;**Benefícios do padrão:**&#10;- ✅ **Flexibilidade** - API pode evoluir independente do banco&#10;- ✅ **Segurança** - Controla exatamente quais dados expor&#10;- ✅ **Manutenibilidade** - Mudanças ficam centralizadas&#10;- ✅ **Testabilidade** - Fácil de testar cada camada&#10;&#10;### 4.2) Implementando o NinjaMapper&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/core/mapper/NinjaMapper.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.core.mapper;&#10;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaQueryRequest;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaRequest;&#10;import br.org.soujava.bsb.api.api.v1.response.NinjaResponse;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import org.mapstruct.Mapper;&#10;import org.mapstruct.factory.Mappers;&#10;&#10;@Mapper&#10;public interface NinjaMapper {&#10;&#10;    NinjaMapper INSTANCE = Mappers.getMapper(NinjaMapper.class);&#10;&#10;    // Converte Request para Entity (para salvar no banco)&#10;    NinjaEntity requestToEntity(NinjaRequest request);&#10;&#10;    // Converte Entity para Response (para retornar na API)&#10;    NinjaResponse entityToResponse(NinjaEntity entity);&#10;&#10;    // Converte Query para Entity (para buscar no banco)&#10;    NinjaEntity queryToEntity(NinjaQueryRequest query);&#10;}&#10;```&#10;&#10;**Como funciona o Mapper:**&#10;- **@Mapper** - Marca a interface para o MapStruct processar&#10;- **INSTANCE** - Forma padrão de obter a implementação gerada&#10;- **Métodos de conversão** - MapStruct gera automaticamente baseado nos nomes dos campos&#10;&#10;### 4.3) Como o MapStruct funciona &quot;por baixo dos panos&quot;&#10;&#10;Quando você compila o projeto, o MapStruct gera automaticamente uma classe `NinjaMapperImpl` como esta:&#10;&#10;```java&#10;// Gerado automaticamente - você não precisa escrever isso!&#10;@Generated(&quot;org.mapstruct.ap.MappingProcessor&quot;)&#10;public class NinjaMapperImpl implements NinjaMapper {&#10;&#10;    @Override&#10;    public NinjaEntity requestToEntity(NinjaRequest request) {&#10;        if (request == null) return null;&#10;        &#10;        NinjaEntity entity = new NinjaEntity();&#10;        entity.setNome(request.nome());&#10;        entity.setVila(request.vila());&#10;        entity.setCla(request.cla());&#10;        // ... todos os outros campos&#10;        return entity;&#10;    }&#10;    &#10;    // ... outros métodos de conversão&#10;}&#10;```&#10;&#10;## 5) Compilando para gerar o Mapper&#10;&#10;Execute no terminal para gerar as implementações:&#10;```bash&#10;# Compila e gera as classes do MapStruct&#10;./mvnw compile&#10;```&#10;&#10;**O que acontece:**&#10;1. MapStruct analisa sua interface `NinjaMapper`&#10;2. Gera automaticamente a classe `NinjaMapperImpl`&#10;3. A classe fica disponível em `target/generated-sources/annotations/`&#10;&#10;**Verificando se funcionou:**&#10;- Olhe em `target/generated-sources/annotations/` &#10;- Deve ter a classe `NinjaMapperImpl` gerada automaticamente&#10;&#10;## 6) Testando o Mapper (opcional)&#10;&#10;Você pode criar um teste simples para verificar se o Mapper funciona:&#10;&#10;```java&#10;@Test&#10;void deveConverterEntityParaResponse() {&#10;    // Given: uma entity&#10;    NinjaEntity entity = new NinjaEntity();&#10;    entity.setId(1);&#10;    entity.setNome(&quot;Naruto&quot;);&#10;    entity.setVila(&quot;Konoha&quot;);&#10;    &#10;    // When: converter para response&#10;    NinjaResponse response = NinjaMapper.INSTANCE.entityToResponse(entity);&#10;    &#10;    // Then: deve ter os dados corretos&#10;    assertThat(response.id()).isEqualTo(1);&#10;    assertThat(response.nome()).isEqualTo(&quot;Naruto&quot;);&#10;    assertThat(response.vila()).isEqualTo(&quot;Konoha&quot;);&#10;}&#10;```&#10;&#10;## Próximo passo&#10;Agora vamos criar o Service, que contém a lógica de negócio da nossa aplicação. **[STEP 5 — Service](README_STEP_5.md)**&#10;" />
              <option name="updatedContent" value="# Passo 4 - DTOs e Mapper (Objetos para API)&#10;&#10;## O que vamos fazer&#10;Vamos criar os DTOs (objetos que trafegam na API), adicionar o MapStruct ao projeto e criar o Mapper (converte automaticamente entre diferentes objetos).&#10;&#10;## 1) O que são DTOs?&#10;&#10;**DTO** = Data Transfer Object (Objeto de Transferência de Dados)&#10;&#10;- São objetos simples que carregam dados entre camadas da aplicação&#10;- **Request**: dados que chegam na API (quando alguém envia dados)&#10;- **Response**: dados que saem da API (quando retornamos dados)&#10;- **Query**: filtros de busca&#10;&#10;**Por que usar DTOs?**&#10;- Separar o que vai na API do que fica no banco&#10;- Controlar exatamente quais campos aparecem&#10;- Validar dados de entrada&#10;- Evoluir a API sem afetar o banco de dados&#10;&#10;## 2) Adicionando dependências do MapStruct&#10;&#10;Antes de criar nossos DTOs e Mapper, precisamos adicionar as dependências do MapStruct no `pom.xml`.&#10;&#10;### 2.1) Por que usar MapStruct?&#10;&#10;**Sem MapStruct (conversão manual):**&#10;```java&#10;// Muito código repetitivo e propenso a erros&#10;public NinjaResponse toResponse(NinjaEntity entity) {&#10;    NinjaResponse response = new NinjaResponse();&#10;    response.setId(entity.getId());&#10;    response.setNome(entity.getNome());&#10;    response.setVila(entity.getVila());&#10;    response.setCla(entity.getCla());&#10;    response.setRank(entity.getRank());&#10;    // ... mais 6 campos para copiar manualmente&#10;    return response;&#10;}&#10;```&#10;&#10;**Com MapStruct (automático):**&#10;```java&#10;// Uma linha só! MapStruct gera todo código automaticamente&#10;NinjaResponse response = ninjaMapper.entityToResponse(entity);&#10;```&#10;&#10;**Vantagens do MapStruct:**&#10;- ✅ **Automático** - Gera código de conversão na compilação&#10;- ✅ **Rápido** - Mais rápido que reflexão&#10;- ✅ **Seguro** - Detecta erros em tempo de compilação&#10;- ✅ **Limpo** - Menos código para manter&#10;&#10;### 2.2) Adicionando no pom.xml&#10;&#10;Adicione essas dependências na seção `&lt;dependencies&gt;` do seu `pom.xml`:&#10;&#10;```xml&#10;&lt;!-- MapStruct --&gt;&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#10;    &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;&#10;    &lt;version&gt;1.6.3&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;&#10;&lt;!-- MapStruct Processor (para gerar código automaticamente) --&gt;&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#10;    &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;&#10;    &lt;version&gt;1.6.3&lt;/version&gt;&#10;    &lt;scope&gt;provided&lt;/scope&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;**Importante:** O `mapstruct-processor` é fundamental! Ele gera automaticamente as classes de implementação durante a compilação.&#10;&#10;## 3) Criando os DTOs&#10;&#10;### 3.1) NinjaRequest (para receber dados)&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/api/v1/request/NinjaRequest.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.api.v1.request;&#10;&#10;import com.fasterxml.jackson.annotation.JsonInclude;&#10;import com.fasterxml.jackson.databind.PropertyNamingStrategies;&#10;import com.fasterxml.jackson.databind.annotation.JsonNaming;&#10;import java.time.LocalDate;&#10;&#10;@JsonInclude(JsonInclude.Include.NON_NULL)&#10;@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)&#10;public record NinjaRequest(&#10;    String nome,&#10;    String vila,&#10;    String cla,&#10;    String rank,&#10;    String chakraTipo,&#10;    String especialidade,&#10;    String kekkeiGenkai,&#10;    String status,&#10;    Integer nivelForca,&#10;    LocalDate dataRegistro&#10;) {}&#10;```&#10;&#10;**Explicando as anotações:**&#10;- `@JsonInclude(NON_NULL)` - só inclui campos que não são nulos&#10;- `@JsonNaming(SnakeCaseStrategy.class)` - converte `chakraTipo` para `chakra_tipo` no JSON&#10;&#10;### 3.2) NinjaResponse (para enviar dados)&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/api/v1/response/NinjaResponse.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.api.v1.response;&#10;&#10;import com.fasterxml.jackson.annotation.JsonInclude;&#10;import com.fasterxml.jackson.databind.PropertyNamingStrategies;&#10;import com.fasterxml.jackson.databind.annotation.JsonNaming;&#10;import java.time.LocalDate;&#10;&#10;@JsonInclude(JsonInclude.Include.NON_NULL)&#10;@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)&#10;public record NinjaResponse(&#10;    Integer id,&#10;    String nome,&#10;    String vila,&#10;    String cla,&#10;    String rank,&#10;    String chakraTipo,&#10;    String especialidade,&#10;    String kekkeiGenkai,&#10;    String status,&#10;    Integer nivelForca,&#10;    LocalDate dataRegistro&#10;) {}&#10;```&#10;&#10;### 3.3) NinjaQueryRequest (para filtros)&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/api/v1/request/NinjaQueryRequest.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.api.v1.request;&#10;&#10;import com.fasterxml.jackson.annotation.JsonInclude;&#10;import com.fasterxml.jackson.databind.PropertyNamingStrategies;&#10;import com.fasterxml.jackson.databind.annotation.JsonNaming;&#10;&#10;@JsonInclude(JsonInclude.Include.NON_NULL)&#10;@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)&#10;public record NinjaQueryRequest(&#10;    String nome,&#10;    String vila,&#10;    String rank,&#10;    String chakraTipo,&#10;    String status&#10;) {}&#10;```&#10;&#10;## 4) Criando o Mapper&#10;&#10;O **Mapper** converte automaticamente entre objetos diferentes. Usamos o MapStruct para isso.&#10;&#10;### 4.1) Por que usar o padrão Mapper?&#10;&#10;**Separação de responsabilidades:**&#10;- **Entity** - Representa dados no banco&#10;- **DTO** - Representa dados na API&#10;- **Mapper** - Faz a ponte entre Entity e DTO&#10;&#10;**Benefícios do padrão:**&#10;- ✅ **Flexibilidade** - API pode evoluir independente do banco&#10;- ✅ **Segurança** - Controla exatamente quais dados expor&#10;- ✅ **Manutenibilidade** - Mudanças ficam centralizadas&#10;- ✅ **Testabilidade** - Fácil de testar cada camada&#10;&#10;### 4.2) Implementando o NinjaMapper&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/core/mapper/NinjaMapper.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.core.mapper;&#10;&#10;import static org.mapstruct.NullValueCheckStrategy.ALWAYS;&#10;import static org.mapstruct.NullValuePropertyMappingStrategy.IGNORE;&#10;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaQueryRequest;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaRequest;&#10;import br.org.soujava.bsb.api.api.v1.response.NinjaResponse;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import org.mapstruct.Mapper;&#10;import org.mapstruct.MappingTarget;&#10;import org.mapstruct.ReportingPolicy;&#10;import org.mapstruct.factory.Mappers;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageImpl;&#10;import org.springframework.stereotype.Component;&#10;&#10;@Mapper(nullValuePropertyMappingStrategy = IGNORE,&#10;        nullValueCheckStrategy = ALWAYS,&#10;        unmappedTargetPolicy = ReportingPolicy.IGNORE&#10;)&#10;@Component&#10;public interface NinjaMapper {&#10;&#10;    NinjaMapper MAPPER = Mappers.getMapper(NinjaMapper.class);&#10;&#10;    // Converte Query para Entity (para buscar no banco)&#10;    NinjaEntity toEntity(NinjaQueryRequest request);&#10;&#10;    // Converte Request para Entity (para salvar no banco)&#10;    NinjaEntity toEntity(NinjaRequest request);&#10;&#10;    // Converte Request para Entity existente (para atualização)&#10;    NinjaEntity toEntity(NinjaRequest request, @MappingTarget NinjaEntity entity);&#10;&#10;    // Converte Entity para Response (para retornar na API)&#10;    NinjaResponse toResponse(NinjaEntity entity);&#10;&#10;    // Converte lista de Entity para lista de Response&#10;    default List&lt;NinjaResponse&gt; toListResponse(List&lt;NinjaEntity&gt; entities) {&#10;        final List&lt;NinjaResponse&gt; list = new ArrayList&lt;&gt;();&#10;        entities.forEach(e -&gt; list.add(toResponse(e)));&#10;        return list;&#10;    }&#10;&#10;    // Converte Page de Entity para Page de Response&#10;    default Page&lt;NinjaResponse&gt; toPageResponse(Page&lt;NinjaEntity&gt; pages) {&#10;        final List&lt;NinjaResponse&gt; list = toListResponse(pages.getContent());&#10;        return new PageImpl&lt;&gt;(list, pages.getPageable(), pages.getTotalElements());&#10;    }&#10;}&#10;```&#10;&#10;**Como funciona o Mapper:**&#10;- **@Mapper** - Marca a interface para o MapStruct processar&#10;- **INSTANCE** - Forma padrão de obter a implementação gerada&#10;- **Métodos de conversão** - MapStruct gera automaticamente baseado nos nomes dos campos&#10;&#10;### 4.3) Como o MapStruct funciona &quot;por baixo dos panos&quot;&#10;&#10;Quando você compila o projeto, o MapStruct gera automaticamente uma classe `NinjaMapperImpl` como esta:&#10;&#10;```java&#10;// Gerado automaticamente - você não precisa escrever isso!&#10;@Generated(&quot;org.mapstruct.ap.MappingProcessor&quot;)&#10;public class NinjaMapperImpl implements NinjaMapper {&#10;&#10;    @Override&#10;    public NinjaEntity requestToEntity(NinjaRequest request) {&#10;        if (request == null) return null;&#10;        &#10;        NinjaEntity entity = new NinjaEntity();&#10;        entity.setNome(request.nome());&#10;        entity.setVila(request.vila());&#10;        entity.setCla(request.cla());&#10;        // ... todos os outros campos&#10;        return entity;&#10;    }&#10;    &#10;    // ... outros métodos de conversão&#10;}&#10;```&#10;&#10;## 5) Compilando para gerar o Mapper&#10;&#10;Execute no terminal para gerar as implementações:&#10;```bash&#10;# Compila e gera as classes do MapStruct&#10;./mvnw compile&#10;```&#10;&#10;**O que acontece:**&#10;1. MapStruct analisa sua interface `NinjaMapper`&#10;2. Gera automaticamente a classe `NinjaMapperImpl`&#10;3. A classe fica disponível em `target/generated-sources/annotations/`&#10;&#10;**Verificando se funcionou:**&#10;- Olhe em `target/generated-sources/annotations/` &#10;- Deve ter a classe `NinjaMapperImpl` gerada automaticamente&#10;&#10;## 6) Testando o Mapper (opcional)&#10;&#10;Você pode criar um teste simples para verificar se o Mapper funciona:&#10;&#10;```java&#10;@Test&#10;void deveConverterEntityParaResponse() {&#10;    // Given: uma entity&#10;    NinjaEntity entity = new NinjaEntity();&#10;    entity.setId(1);&#10;    entity.setNome(&quot;Naruto&quot;);&#10;    entity.setVila(&quot;Konoha&quot;);&#10;    &#10;    // When: converter para response&#10;    NinjaResponse response = NinjaMapper.INSTANCE.entityToResponse(entity);&#10;    &#10;    // Then: deve ter os dados corretos&#10;    assertThat(response.id()).isEqualTo(1);&#10;    assertThat(response.nome()).isEqualTo(&quot;Naruto&quot;);&#10;    assertThat(response.vila()).isEqualTo(&quot;Konoha&quot;);&#10;}&#10;```&#10;&#10;## Próximo passo&#10;Agora vamos criar o Service, que contém a lógica de negócio da nossa aplicação. **[STEP 5 — Service](README_STEP_5.md)**" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/README_STEP_5.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/README_STEP_5.md" />
              <option name="originalContent" value="# Passo 5 - Service (Lógica de Negócio)&#10;&#10;## O que vamos fazer&#10;Vamos criar o `NinjaService` que contém toda a lógica de negócio: criar, buscar, atualizar e deletar ninjas.&#10;&#10;## 1) O que é um Service?&#10;&#10;O **Service** é onde fica a lógica da sua aplicação:&#10;- Regras de negócio&#10;- Validações&#10;- Operações CRUD (Create, Read, Update, Delete)&#10;- Comunicação com o Repository&#10;&#10;**Arquitetura em camadas:**&#10;- **Controller** → recebe requisições HTTP&#10;- **Service** → processa a lógica de negócio  &#10;- **Repository** → acessa o banco de dados&#10;&#10;## 2) Criando uma exceção personalizada&#10;&#10;Primeiro, vamos criar uma exceção para quando não encontrarmos um ninja.&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/domain/exception/ResourceNotFoundException.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.exception;&#10;&#10;public class ResourceNotFoundException extends RuntimeException {&#10;&#10;    public ResourceNotFoundException(String message) {&#10;        super(message);&#10;    }&#10;&#10;    public ResourceNotFoundException(String message, Throwable cause) {&#10;        super(message, cause);&#10;    }&#10;}&#10;```&#10;&#10;## 3) Criando o NinjaService&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/domain/service/NinjaService.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.service;&#10;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaQueryRequest;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaRequest;&#10;import br.org.soujava.bsb.api.api.v1.response.NinjaResponse;&#10;import br.org.soujava.bsb.api.core.mapper.NinjaMapper;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import br.org.soujava.bsb.api.domain.exception.ResourceNotFoundException;&#10;import br.org.soujava.bsb.api.domain.repository.NinjaRepository;&#10;import org.springframework.data.domain.Example;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.List;&#10;&#10;@Service&#10;public class NinjaService {&#10;&#10;    private final NinjaRepository ninjaRepository;&#10;    private final NinjaMapper ninjaMapper;&#10;&#10;    public NinjaService(NinjaRepository ninjaRepository, NinjaMapper ninjaMapper) {&#10;        this.ninjaRepository = ninjaRepository;&#10;        this.ninjaMapper = ninjaMapper;&#10;    }&#10;&#10;    // 1) BUSCAR TODOS OS NINJAS&#10;    public List&lt;NinjaResponse&gt; findAll() {&#10;        return ninjaRepository.findAll()&#10;                .stream()&#10;                .map(ninjaMapper::entityToResponse)&#10;                .toList();&#10;    }&#10;&#10;    // 2) BUSCAR NINJA POR ID&#10;    public NinjaResponse findById(Integer id) {&#10;        NinjaEntity ninja = ninjaRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Ninja não encontrado com ID: &quot; + id));&#10;        &#10;        return ninjaMapper.entityToResponse(ninja);&#10;    }&#10;&#10;    // 3) BUSCAR COM FILTROS&#10;    public List&lt;NinjaResponse&gt; findByQuery(NinjaQueryRequest query) {&#10;        NinjaEntity example = ninjaMapper.queryToEntity(query);&#10;        Example&lt;NinjaEntity&gt; ninjaExample = Example.of(example);&#10;        &#10;        return ninjaRepository.findAll(ninjaExample)&#10;                .stream()&#10;                .map(ninjaMapper::entityToResponse)&#10;                .toList();&#10;    }&#10;&#10;    // 4) CRIAR NOVO NINJA&#10;    public NinjaResponse create(NinjaRequest request) {&#10;        NinjaEntity ninja = ninjaMapper.requestToEntity(request);&#10;        NinjaEntity savedNinja = ninjaRepository.save(ninja);&#10;        &#10;        return ninjaMapper.entityToResponse(savedNinja);&#10;    }&#10;&#10;    // 5) ATUALIZAR NINJA EXISTENTE&#10;    public NinjaResponse update(Integer id, NinjaRequest request) {&#10;        // Verifica se o ninja existe&#10;        NinjaEntity existingNinja = ninjaRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Ninja não encontrado com ID: &quot; + id));&#10;        &#10;        // Converte o request para entity&#10;        NinjaEntity ninja = ninjaMapper.requestToEntity(request);&#10;        ninja.setId(id); // Mantém o ID original&#10;        &#10;        // Salva e retorna&#10;        NinjaEntity updatedNinja = ninjaRepository.save(ninja);&#10;        return ninjaMapper.entityToResponse(updatedNinja);&#10;    }&#10;&#10;    // 6) DELETAR NINJA&#10;    public void deleteById(Integer id) {&#10;        // Verifica se o ninja existe antes de deletar&#10;        if (!ninjaRepository.existsById(id)) {&#10;            throw new ResourceNotFoundException(&quot;Ninja não encontrado com ID: &quot; + id);&#10;        }&#10;        &#10;        ninjaRepository.deleteById(id);&#10;    }&#10;}&#10;```&#10;&#10;## 4) Entendendo o código&#10;&#10;**Injeção de dependência:**&#10;```java&#10;private final NinjaRepository ninjaRepository;&#10;private final NinjaMapper ninjaMapper;&#10;```&#10;O Spring injeta automaticamente essas dependências.&#10;&#10;**Busca com Example:**&#10;```java&#10;Example&lt;NinjaEntity&gt; ninjaExample = Example.of(example);&#10;```&#10;O `Example` permite buscar registros que &quot;parecem&quot; com o objeto exemplo (campos não nulos são usados como filtro).&#10;&#10;**Tratamento de erro:**&#10;```java&#10;.orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Ninja não encontrado&quot;));&#10;```&#10;Se não encontrar o ninja, lança nossa exceção personalizada.&#10;&#10;**Stream para conversão:**&#10;```java&#10;.stream().map(ninjaMapper::entityToResponse).toList()&#10;```&#10;Converte cada `NinjaEntity` em `NinjaResponse`.&#10;&#10;## 5) Testando o Service com NinjaServiceTest&#10;&#10;Agora vamos criar testes unitários para validar se nosso Service está funcionando corretamente. Testes de Service são diferentes dos testes de Repository - aqui usamos **Mocks** para simular as dependências.&#10;&#10;### 5.1) Por que testar o Service?&#10;&#10;**Testes de Service validam:**&#10;- ✅ Lógica de negócio funciona corretamente&#10;- ✅ Tratamento de exceções está adequado&#10;- ✅ Interações com Repository acontecem como esperado&#10;- ✅ Conversões entre DTOs e Entities estão corretas&#10;&#10;### 5.2) Diferença entre testes de Repository e Service&#10;&#10;| **Repository Test** | **Service Test** |&#10;|-------------------|------------------|&#10;| Testa integração com banco | Testa lógica de negócio |&#10;| Usa banco H2 real | Usa mocks das dependências |&#10;| `@DataJpaTest` | `@ExtendWith(MockitoExtension.class)` |&#10;| Carrega contexto JPA | Não carrega contexto Spring |&#10;&#10;### 5.3) Criando a classe de teste&#10;&#10;Crie o arquivo `src/test/java/br/org/soujava/bsb/api/domain/service/NinjaServiceTest.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.service;&#10;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaQueryRequest;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaRequest;&#10;import br.org.soujava.bsb.api.api.v1.response.NinjaResponse;&#10;import br.org.soujava.bsb.api.core.mapper.NinjaMapper;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import br.org.soujava.bsb.api.domain.exception.ResourceNotFoundException;&#10;import br.org.soujava.bsb.api.domain.repository.NinjaRepository;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.data.domain.Example;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.assertj.core.api.Assertions.assertThat;&#10;import static org.assertj.core.api.Assertions.assertThatThrownBy;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.Mockito.times;&#10;import static org.mockito.Mockito.verify;&#10;import static org.mockito.Mockito.when;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot;Ninja Service&quot;)&#10;class NinjaServiceTest {&#10;&#10;    @Mock&#10;    private NinjaRepository ninjaRepository;&#10;&#10;    @Mock&#10;    private NinjaMapper ninjaMapper;&#10;&#10;    @InjectMocks&#10;    private NinjaService ninjaService;&#10;&#10;    private NinjaEntity ninjaEntity;&#10;    private NinjaRequest ninjaRequest;&#10;    private NinjaResponse ninjaResponse;&#10;    private NinjaQueryRequest ninjaQueryRequest;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Preparar dados de teste que serão reutilizados&#10;        ninjaEntity = new NinjaEntity();&#10;        ninjaEntity.setId(1);&#10;        ninjaEntity.setNome(&quot;Naruto Uzumaki&quot;);&#10;        ninjaEntity.setVila(&quot;Konoha&quot;);&#10;        ninjaEntity.setCla(&quot;Uzumaki&quot;);&#10;        ninjaEntity.setRank(&quot;Hokage&quot;);&#10;        ninjaEntity.setChakraTipo(&quot;Vento&quot;);&#10;        ninjaEntity.setEspecialidade(&quot;Ninjutsu&quot;);&#10;        ninjaEntity.setKekkeiGenkai(&quot;Kurama (Bijuu)&quot;);&#10;        ninjaEntity.setStatus(&quot;Ativo&quot;);&#10;        ninjaEntity.setNivelForca(98);&#10;        ninjaEntity.setDataRegistro(LocalDate.now());&#10;&#10;        ninjaRequest = new NinjaRequest(&#10;                &quot;Naruto Uzumaki&quot;,&#10;                &quot;Konoha&quot;,&#10;                &quot;Uzumaki&quot;,&#10;                &quot;Hokage&quot;,&#10;                &quot;Vento&quot;,&#10;                &quot;Ninjutsu&quot;,&#10;                &quot;Kurama (Bijuu)&quot;,&#10;                &quot;Ativo&quot;,&#10;                98,&#10;                LocalDate.now()&#10;        );&#10;&#10;        ninjaResponse = new NinjaResponse(&#10;                1,&#10;                &quot;Naruto Uzumaki&quot;,&#10;                &quot;Konoha&quot;,&#10;                &quot;Uzumaki&quot;,&#10;                &quot;Hokage&quot;,&#10;                &quot;Vento&quot;,&#10;                &quot;Ninjutsu&quot;,&#10;                &quot;Kurama (Bijuu)&quot;,&#10;                &quot;Ativo&quot;,&#10;                98,&#10;                LocalDate.now()&#10;        );&#10;&#10;        ninjaQueryRequest = new NinjaQueryRequest(&#10;                &quot;Naruto&quot;,&#10;                &quot;Konoha&quot;,&#10;                &quot;Hokage&quot;,&#10;                &quot;Vento&quot;,&#10;                &quot;Ativo&quot;&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve criar ninja com sucesso&quot;)&#10;    void deveCriarNinjaComSucesso() {&#10;        // Given: configurar comportamento dos mocks&#10;        when(ninjaMapper.requestToEntity(ninjaRequest)).thenReturn(ninjaEntity);&#10;        when(ninjaRepository.save(any(NinjaEntity.class))).thenReturn(ninjaEntity);&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: chamar create&#10;        NinjaResponse resultado = ninjaService.create(ninjaRequest);&#10;&#10;        // Then: deve retornar ninja criado&#10;        assertThat(resultado).isNotNull();&#10;        assertThat(resultado.id()).isEqualTo(1);&#10;        assertThat(resultado.nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;        assertThat(resultado.vila()).isEqualTo(&quot;Konoha&quot;);&#10;&#10;        // Verificar que os mocks foram chamados corretamente&#10;        verify(ninjaMapper, times(1)).requestToEntity(ninjaRequest);&#10;        verify(ninjaRepository, times(1)).save(any(NinjaEntity.class));&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve buscar ninja por ID existente com sucesso&quot;)&#10;    void deveBuscarNinjaPorIdExistenteComSucesso() {&#10;        // Given: repository retornará o ninja&#10;        when(ninjaRepository.findById(1)).thenReturn(Optional.of(ninjaEntity));&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: buscar ninja por ID&#10;        NinjaResponse resultado = ninjaService.findById(1);&#10;&#10;        // Then: deve retornar o ninja encontrado&#10;        assertThat(resultado).isNotNull();&#10;        assertThat(resultado.id()).isEqualTo(1);&#10;        assertThat(resultado.nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;&#10;        // Verificar interações com mocks&#10;        verify(ninjaRepository, times(1)).findById(1);&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar exceção ao buscar ninja por ID inexistente&quot;)&#10;    void deveLancarExcecaoAoBuscarNinjaPorIdInexistente() {&#10;        // Given: repository retornará Optional vazio&#10;        when(ninjaRepository.findById(999)).thenReturn(Optional.empty());&#10;&#10;        // When/Then: deve lançar ResourceNotFoundException&#10;        assertThatThrownBy(() -&gt; ninjaService.findById(999))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Ninja não encontrado com ID: 999&quot;);&#10;&#10;        // Verificar que o repository foi chamado&#10;        verify(ninjaRepository, times(1)).findById(999);&#10;        // Verificar que o mapper NÃO foi chamado (ninja não encontrado)&#10;        verify(ninjaMapper, times(0)).entityToResponse(any());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve buscar todos os ninjas com sucesso&quot;)&#10;    void deveBuscarTodosOsNinjasComSucesso() {&#10;        // Given: repository retornará lista de ninjas&#10;        List&lt;NinjaEntity&gt; ninjas = List.of(ninjaEntity);&#10;        when(ninjaRepository.findAll()).thenReturn(ninjas);&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: buscar todos&#10;        List&lt;NinjaResponse&gt; resultado = ninjaService.findAll();&#10;&#10;        // Then: deve retornar lista com ninjas&#10;        assertThat(resultado).hasSize(1);&#10;        assertThat(resultado.get(0).nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;&#10;        // Verificar interações&#10;        verify(ninjaRepository, times(1)).findAll();&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve buscar ninjas com filtros usando Example&quot;)&#10;    void deveBuscarNinjasComFiltros() {&#10;        // Given: preparar mocks&#10;        NinjaEntity entityFiltro = new NinjaEntity();&#10;        entityFiltro.setNome(&quot;Naruto&quot;);&#10;        entityFiltro.setVila(&quot;Konoha&quot;);&#10;        &#10;        List&lt;NinjaEntity&gt; ninjas = List.of(ninjaEntity);&#10;        &#10;        when(ninjaMapper.queryToEntity(ninjaQueryRequest)).thenReturn(entityFiltro);&#10;        when(ninjaRepository.findAll(any(Example.class))).thenReturn(ninjas);&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: fazer busca com filtros&#10;        List&lt;NinjaResponse&gt; resultado = ninjaService.findByQuery(ninjaQueryRequest);&#10;&#10;        // Then: deve retornar resultados filtrados&#10;        assertThat(resultado).hasSize(1);&#10;        assertThat(resultado.get(0).nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;&#10;        // Verificar interações&#10;        verify(ninjaMapper, times(1)).queryToEntity(ninjaQueryRequest);&#10;        verify(ninjaRepository, times(1)).findAll(any(Example.class));&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve atualizar ninja existente com sucesso&quot;)&#10;    void deveAtualizarNinjaExistenteComSucesso() {&#10;        // Given: ninja existe&#10;        when(ninjaRepository.findById(1)).thenReturn(Optional.of(ninjaEntity));&#10;        when(ninjaMapper.requestToEntity(ninjaRequest)).thenReturn(ninjaEntity);&#10;        when(ninjaRepository.save(any(NinjaEntity.class))).thenReturn(ninjaEntity);&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: atualizar ninja&#10;        NinjaResponse resultado = ninjaService.update(1, ninjaRequest);&#10;&#10;        // Then: deve retornar ninja atualizado&#10;        assertThat(resultado).isNotNull();&#10;        assertThat(resultado.nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;&#10;        // Verificar interações&#10;        verify(ninjaRepository, times(1)).findById(1);&#10;        verify(ninjaMapper, times(1)).requestToEntity(ninjaRequest);&#10;        verify(ninjaRepository, times(1)).save(any(NinjaEntity.class));&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar exceção ao tentar atualizar ninja inexistente&quot;)&#10;    void deveLancarExcecaoAoTentarAtualizarNinjaInexistente() {&#10;        // Given: ninja não existe&#10;        when(ninjaRepository.findById(999)).thenReturn(Optional.empty());&#10;&#10;        // When/Then: deve lançar exceção&#10;        assertThatThrownBy(() -&gt; ninjaService.update(999, ninjaRequest))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Ninja não encontrado com ID: 999&quot;);&#10;&#10;        // Verificar que apenas findById foi chamado&#10;        verify(ninjaRepository, times(1)).findById(999);&#10;        verify(ninjaRepository, times(0)).save(any());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve deletar ninja existente com sucesso&quot;)&#10;    void deveDeletarNinjaExistenteComSucesso() {&#10;        // Given: ninja existe&#10;        when(ninjaRepository.existsById(1)).thenReturn(true);&#10;&#10;        // When: deletar ninja&#10;        ninjaService.deleteById(1);&#10;&#10;        // Then: deve chamar deleteById no repository&#10;        verify(ninjaRepository, times(1)).existsById(1);&#10;        verify(ninjaRepository, times(1)).deleteById(1);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar exceção ao tentar deletar ninja inexistente&quot;)&#10;    void deveLancarExcecaoAoTentarDeletarNinjaInexistente() {&#10;        // Given: ninja não existe&#10;        when(ninjaRepository.existsById(999)).thenReturn(false);&#10;&#10;        // When/Then: deve lançar exceção&#10;        assertThatThrownBy(() -&gt; ninjaService.deleteById(999))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Ninja não encontrado com ID: 999&quot;);&#10;&#10;        // Verificar que deleteById NÃO foi chamado&#10;        verify(ninjaRepository, times(1)).existsById(999);&#10;        verify(ninjaRepository, times(0)).deleteById(999);&#10;    }&#10;}&#10;```&#10;&#10;### 5.4) Entendendo as anotações de teste&#10;&#10;**@ExtendWith(MockitoExtension.class)**&#10;- Habilita o uso do Mockito para criar mocks&#10;- Não carrega o contexto Spring (teste mais rápido)&#10;&#10;**@Mock**&#10;- Cria um objeto &quot;falso&quot; (mock) da dependência&#10;- Permite controlar o comportamento do objeto&#10;&#10;**@InjectMocks**&#10;- Injeta os mocks automaticamente no objeto testado&#10;- Cria uma instância real do NinjaService com mocks injetados&#10;&#10;**@BeforeEach**&#10;- Executa antes de cada teste&#10;- Prepara dados que serão reutilizados&#10;&#10;### 5.5) Entendendo o Mockito&#10;&#10;**when().thenReturn()** - Define comportamento do mock:&#10;```java&#10;when(ninjaRepository.findById(1)).thenReturn(Optional.of(ninjaEntity));&#10;// Quando chamar findById(1), retorne Optional.of(ninjaEntity)&#10;```&#10;&#10;**verify()** - Verifica se método foi chamado:&#10;```java&#10;verify(ninjaRepository, times(1)).findById(1);&#10;// Verifica que findById(1) foi chamado exatamente 1 vez&#10;```&#10;&#10;**any()** - Aceita qualquer valor como parâmetro:&#10;```java&#10;verify(ninjaRepository).save(any(NinjaEntity.class));&#10;// Verifica que save foi chamado com qualquer NinjaEntity&#10;```&#10;&#10;### 5.6) Padrão AAA (Arrange-Act-Assert)&#10;&#10;Nossos testes seguem o padrão AAA:&#10;&#10;```java&#10;// Arrange (Given): Preparar mocks e dados&#10;when(ninjaRepository.findById(1)).thenReturn(Optional.of(ninjaEntity));&#10;&#10;// Act (When): Executar ação que queremos testar&#10;NinjaResponse resultado = ninjaService.findById(1);&#10;&#10;// Assert (Then): Verificar resultados e interações&#10;assertThat(resultado).isNotNull();&#10;verify(ninjaRepository).findById(1);&#10;```&#10;&#10;### 5.7) Executando os testes&#10;&#10;**No terminal:**&#10;```bash&#10;# Executa todos os testes&#10;./mvnw test&#10;&#10;# Executa apenas testes do Service&#10;./mvnw test -Dtest=NinjaServiceTest&#10;```&#10;&#10;### 5.8) O que cada teste valida&#10;&#10;1. **deveCriarNinjaComSucesso()** - Criação funcionando corretamente&#10;2. **deveBuscarNinjaPorIdExistenteComSucesso()** - Busca por ID válido&#10;3. **deveLancarExcecaoAoBuscarNinjaPorIdInexistente()** - Tratamento de ninja não encontrado&#10;4. **deveBuscarTodosOsNinjasComSucesso()** - Listagem completa&#10;5. **deveBuscarNinjasComFiltros()** - Busca com Example&#10;6. **deveAtualizarNinjaExistenteComSucesso()** - Atualização funcionando&#10;7. **deveLancarExcecaoAoTentarAtualizarNinjaInexistente()** - Atualização com ID inválido&#10;8. **deveDeletarNinjaExistenteComSucesso()** - Exclusão funcionando&#10;9. **deveLancarExcecaoAoTentarDeletarNinjaInexistente()** - Exclusão com ID inválido&#10;&#10;### 5.9) Benefícios dos testes com Mock&#10;&#10;✅ **Rápidos** - Não acessam banco de dados&#10;✅ **Isolados** - Testam apenas lógica do Service&#10;✅ **Confiáveis** - Controlam exatamente o comportamento das dependências&#10;✅ **Precisos** - Verificam interações específicas&#10;&#10;## Próximo passo&#10;Agora vamos criar o Controller, que vai expor os endpoints HTTP da nossa API. **[STEP 6 — Controller com Validações (Endpoints da API)](README_STEP_6.md)**&#10;" />
              <option name="updatedContent" value="# Passo 5 - Service (Lógica de Negócio)&#10;&#10;## O que vamos fazer&#10;Vamos criar o `NinjaService` que contém toda a lógica de negócio: criar, buscar, atualizar e deletar ninjas.&#10;&#10;## 1) O que é um Service?&#10;&#10;O **Service** é onde fica a lógica da sua aplicação:&#10;- Regras de negócio&#10;- Validações&#10;- Operações CRUD (Create, Read, Update, Delete)&#10;- Comunicação com o Repository&#10;&#10;**Arquitetura em camadas:**&#10;- **Controller** → recebe requisições HTTP&#10;- **Service** → processa a lógica de negócio  &#10;- **Repository** → acessa o banco de dados&#10;&#10;## 2) Criando uma exceção personalizada&#10;&#10;Primeiro, vamos criar uma exceção para quando não encontrarmos um ninja.&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/domain/exception/ResourceNotFoundException.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.exception;&#10;&#10;public class ResourceNotFoundException extends RuntimeException {&#10;&#10;    public ResourceNotFoundException(String message) {&#10;        super(message);&#10;    }&#10;&#10;    public ResourceNotFoundException(String message, Throwable cause) {&#10;        super(message, cause);&#10;    }&#10;}&#10;```&#10;&#10;## 3) Criando o NinjaService&#10;&#10;Crie `src/main/java/br/org/soujava/bsb/api/domain/service/NinjaService.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.service;&#10;&#10;import static br.org.soujava.bsb.api.core.mapper.NinjaMapper.MAPPER;&#10;import static java.text.MessageFormat.format;&#10;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaQueryRequest;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaRequest;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import br.org.soujava.bsb.api.domain.exception.ResourceNotFoundException;&#10;import br.org.soujava.bsb.api.domain.repository.NinjaRepository;&#10;import org.springframework.data.domain.Example;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;@Service&#10;public class NinjaService {&#10;&#10;    private final NinjaRepository respository;&#10;&#10;    public NinjaService(NinjaRepository respository) {&#10;        this.respository = respository;&#10;    }&#10;&#10;    @Transactional&#10;    public NinjaEntity create(NinjaRequest ninjaRequest) {&#10;        return respository.save(MAPPER.toEntity(ninjaRequest));&#10;    }&#10;&#10;    @Transactional(readOnly = true)&#10;    public NinjaEntity findById(Integer id) throws ResourceNotFoundException {&#10;        return respository.findById(id)&#10;                .orElseThrow(() -&gt; new ResourceNotFoundException(format(&quot;Not found regitstry with code {0}&quot;, id)));&#10;    }&#10;&#10;    @Transactional(readOnly = true)&#10;    public Page&lt;NinjaEntity&gt; search(NinjaQueryRequest queryRequest, Pageable pageable) {&#10;        final var ninjaEntityExample = Example.of(MAPPER.toEntity(queryRequest));&#10;        return respository.findAll(ninjaEntityExample, pageable);&#10;    }&#10;&#10;    @Transactional&#10;    public NinjaEntity update(Integer id, NinjaRequest request) throws ResourceNotFoundException {&#10;        final var ninja = MAPPER.toEntity(request, findById(id));&#10;        return respository.save(ninja);&#10;    }&#10;&#10;    @Transactional&#10;    public void delete(Integer id) throws ResourceNotFoundException {&#10;        final var ninjaEntity = findById(id);&#10;        respository.delete(ninjaEntity);&#10;    }&#10;}&#10;```&#10;&#10;## 4) Entendendo o código&#10;&#10;**Injeção de dependência:**&#10;```java&#10;private final NinjaRepository ninjaRepository;&#10;private final NinjaMapper ninjaMapper;&#10;```&#10;O Spring injeta automaticamente essas dependências.&#10;&#10;**Busca com Example:**&#10;```java&#10;Example&lt;NinjaEntity&gt; ninjaExample = Example.of(example);&#10;```&#10;O `Example` permite buscar registros que &quot;parecem&quot; com o objeto exemplo (campos não nulos são usados como filtro).&#10;&#10;**Tratamento de erro:**&#10;```java&#10;.orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Ninja não encontrado&quot;));&#10;```&#10;Se não encontrar o ninja, lança nossa exceção personalizada.&#10;&#10;**Stream para conversão:**&#10;```java&#10;.stream().map(ninjaMapper::entityToResponse).toList()&#10;```&#10;Converte cada `NinjaEntity` em `NinjaResponse`.&#10;&#10;## 5) Testando o Service com NinjaServiceTest&#10;&#10;Agora vamos criar testes unitários para validar se nosso Service está funcionando corretamente. Testes de Service são diferentes dos testes de Repository - aqui usamos **Mocks** para simular as dependências.&#10;&#10;### 5.1) Por que testar o Service?&#10;&#10;**Testes de Service validam:**&#10;- ✅ Lógica de negócio funciona corretamente&#10;- ✅ Tratamento de exceções está adequado&#10;- ✅ Interações com Repository acontecem como esperado&#10;- ✅ Conversões entre DTOs e Entities estão corretas&#10;&#10;### 5.2) Diferença entre testes de Repository e Service&#10;&#10;| **Repository Test** | **Service Test** |&#10;|-------------------|------------------|&#10;| Testa integração com banco | Testa lógica de negócio |&#10;| Usa banco H2 real | Usa mocks das dependências |&#10;| `@DataJpaTest` | `@ExtendWith(MockitoExtension.class)` |&#10;| Carrega contexto JPA | Não carrega contexto Spring |&#10;&#10;### 5.3) Criando a classe de teste&#10;&#10;Crie o arquivo `src/test/java/br/org/soujava/bsb/api/domain/service/NinjaServiceTest.java`:&#10;&#10;```java&#10;package br.org.soujava.bsb.api.domain.service;&#10;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaQueryRequest;&#10;import br.org.soujava.bsb.api.api.v1.request.NinjaRequest;&#10;import br.org.soujava.bsb.api.api.v1.response.NinjaResponse;&#10;import br.org.soujava.bsb.api.core.mapper.NinjaMapper;&#10;import br.org.soujava.bsb.api.domain.entity.NinjaEntity;&#10;import br.org.soujava.bsb.api.domain.exception.ResourceNotFoundException;&#10;import br.org.soujava.bsb.api.domain.repository.NinjaRepository;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.data.domain.Example;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.assertj.core.api.Assertions.assertThat;&#10;import static org.assertj.core.api.Assertions.assertThatThrownBy;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.Mockito.times;&#10;import static org.mockito.Mockito.verify;&#10;import static org.mockito.Mockito.when;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot;Ninja Service&quot;)&#10;class NinjaServiceTest {&#10;&#10;    @Mock&#10;    private NinjaRepository ninjaRepository;&#10;&#10;    @Mock&#10;    private NinjaMapper ninjaMapper;&#10;&#10;    @InjectMocks&#10;    private NinjaService ninjaService;&#10;&#10;    private NinjaEntity ninjaEntity;&#10;    private NinjaRequest ninjaRequest;&#10;    private NinjaResponse ninjaResponse;&#10;    private NinjaQueryRequest ninjaQueryRequest;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Preparar dados de teste que serão reutilizados&#10;        ninjaEntity = new NinjaEntity();&#10;        ninjaEntity.setId(1);&#10;        ninjaEntity.setNome(&quot;Naruto Uzumaki&quot;);&#10;        ninjaEntity.setVila(&quot;Konoha&quot;);&#10;        ninjaEntity.setCla(&quot;Uzumaki&quot;);&#10;        ninjaEntity.setRank(&quot;Hokage&quot;);&#10;        ninjaEntity.setChakraTipo(&quot;Vento&quot;);&#10;        ninjaEntity.setEspecialidade(&quot;Ninjutsu&quot;);&#10;        ninjaEntity.setKekkeiGenkai(&quot;Kurama (Bijuu)&quot;);&#10;        ninjaEntity.setStatus(&quot;Ativo&quot;);&#10;        ninjaEntity.setNivelForca(98);&#10;        ninjaEntity.setDataRegistro(LocalDate.now());&#10;&#10;        ninjaRequest = new NinjaRequest(&#10;                &quot;Naruto Uzumaki&quot;,&#10;                &quot;Konoha&quot;,&#10;                &quot;Uzumaki&quot;,&#10;                &quot;Hokage&quot;,&#10;                &quot;Vento&quot;,&#10;                &quot;Ninjutsu&quot;,&#10;                &quot;Kurama (Bijuu)&quot;,&#10;                &quot;Ativo&quot;,&#10;                98,&#10;                LocalDate.now()&#10;        );&#10;&#10;        ninjaResponse = new NinjaResponse(&#10;                1,&#10;                &quot;Naruto Uzumaki&quot;,&#10;                &quot;Konoha&quot;,&#10;                &quot;Uzumaki&quot;,&#10;                &quot;Hokage&quot;,&#10;                &quot;Vento&quot;,&#10;                &quot;Ninjutsu&quot;,&#10;                &quot;Kurama (Bijuu)&quot;,&#10;                &quot;Ativo&quot;,&#10;                98,&#10;                LocalDate.now()&#10;        );&#10;&#10;        ninjaQueryRequest = new NinjaQueryRequest(&#10;                &quot;Naruto&quot;,&#10;                &quot;Konoha&quot;,&#10;                &quot;Hokage&quot;,&#10;                &quot;Vento&quot;,&#10;                &quot;Ativo&quot;&#10;        );&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve criar ninja com sucesso&quot;)&#10;    void deveCriarNinjaComSucesso() {&#10;        // Given: configurar comportamento dos mocks&#10;        when(ninjaMapper.requestToEntity(ninjaRequest)).thenReturn(ninjaEntity);&#10;        when(ninjaRepository.save(any(NinjaEntity.class))).thenReturn(ninjaEntity);&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: chamar create&#10;        NinjaResponse resultado = ninjaService.create(ninjaRequest);&#10;&#10;        // Then: deve retornar ninja criado&#10;        assertThat(resultado).isNotNull();&#10;        assertThat(resultado.id()).isEqualTo(1);&#10;        assertThat(resultado.nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;        assertThat(resultado.vila()).isEqualTo(&quot;Konoha&quot;);&#10;&#10;        // Verificar que os mocks foram chamados corretamente&#10;        verify(ninjaMapper, times(1)).requestToEntity(ninjaRequest);&#10;        verify(ninjaRepository, times(1)).save(any(NinjaEntity.class));&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve buscar ninja por ID existente com sucesso&quot;)&#10;    void deveBuscarNinjaPorIdExistenteComSucesso() {&#10;        // Given: repository retornará o ninja&#10;        when(ninjaRepository.findById(1)).thenReturn(Optional.of(ninjaEntity));&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: buscar ninja por ID&#10;        NinjaResponse resultado = ninjaService.findById(1);&#10;&#10;        // Then: deve retornar o ninja encontrado&#10;        assertThat(resultado).isNotNull();&#10;        assertThat(resultado.id()).isEqualTo(1);&#10;        assertThat(resultado.nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;&#10;        // Verificar interações com mocks&#10;        verify(ninjaRepository, times(1)).findById(1);&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar exceção ao buscar ninja por ID inexistente&quot;)&#10;    void deveLancarExcecaoAoBuscarNinjaPorIdInexistente() {&#10;        // Given: repository retornará Optional vazio&#10;        when(ninjaRepository.findById(999)).thenReturn(Optional.empty());&#10;&#10;        // When/Then: deve lançar ResourceNotFoundException&#10;        assertThatThrownBy(() -&gt; ninjaService.findById(999))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Ninja não encontrado com ID: 999&quot;);&#10;&#10;        // Verificar que o repository foi chamado&#10;        verify(ninjaRepository, times(1)).findById(999);&#10;        // Verificar que o mapper NÃO foi chamado (ninja não encontrado)&#10;        verify(ninjaMapper, times(0)).entityToResponse(any());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve buscar todos os ninjas com sucesso&quot;)&#10;    void deveBuscarTodosOsNinjasComSucesso() {&#10;        // Given: repository retornará lista de ninjas&#10;        List&lt;NinjaEntity&gt; ninjas = List.of(ninjaEntity);&#10;        when(ninjaRepository.findAll()).thenReturn(ninjas);&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: buscar todos&#10;        List&lt;NinjaResponse&gt; resultado = ninjaService.findAll();&#10;&#10;        // Then: deve retornar lista com ninjas&#10;        assertThat(resultado).hasSize(1);&#10;        assertThat(resultado.get(0).nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;&#10;        // Verificar interações&#10;        verify(ninjaRepository, times(1)).findAll();&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve buscar ninjas com filtros usando Example&quot;)&#10;    void deveBuscarNinjasComFiltros() {&#10;        // Given: preparar mocks&#10;        NinjaEntity entityFiltro = new NinjaEntity();&#10;        entityFiltro.setNome(&quot;Naruto&quot;);&#10;        entityFiltro.setVila(&quot;Konoha&quot;);&#10;        &#10;        List&lt;NinjaEntity&gt; ninjas = List.of(ninjaEntity);&#10;        &#10;        when(ninjaMapper.queryToEntity(ninjaQueryRequest)).thenReturn(entityFiltro);&#10;        when(ninjaRepository.findAll(any(Example.class))).thenReturn(ninjas);&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: fazer busca com filtros&#10;        List&lt;NinjaResponse&gt; resultado = ninjaService.findByQuery(ninjaQueryRequest);&#10;&#10;        // Then: deve retornar resultados filtrados&#10;        assertThat(resultado).hasSize(1);&#10;        assertThat(resultado.get(0).nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;&#10;        // Verificar interações&#10;        verify(ninjaMapper, times(1)).queryToEntity(ninjaQueryRequest);&#10;        verify(ninjaRepository, times(1)).findAll(any(Example.class));&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve atualizar ninja existente com sucesso&quot;)&#10;    void deveAtualizarNinjaExistenteComSucesso() {&#10;        // Given: ninja existe&#10;        when(ninjaRepository.findById(1)).thenReturn(Optional.of(ninjaEntity));&#10;        when(ninjaMapper.requestToEntity(ninjaRequest)).thenReturn(ninjaEntity);&#10;        when(ninjaRepository.save(any(NinjaEntity.class))).thenReturn(ninjaEntity);&#10;        when(ninjaMapper.entityToResponse(ninjaEntity)).thenReturn(ninjaResponse);&#10;&#10;        // When: atualizar ninja&#10;        NinjaResponse resultado = ninjaService.update(1, ninjaRequest);&#10;&#10;        // Then: deve retornar ninja atualizado&#10;        assertThat(resultado).isNotNull();&#10;        assertThat(resultado.nome()).isEqualTo(&quot;Naruto Uzumaki&quot;);&#10;&#10;        // Verificar interações&#10;        verify(ninjaRepository, times(1)).findById(1);&#10;        verify(ninjaMapper, times(1)).requestToEntity(ninjaRequest);&#10;        verify(ninjaRepository, times(1)).save(any(NinjaEntity.class));&#10;        verify(ninjaMapper, times(1)).entityToResponse(ninjaEntity);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar exceção ao tentar atualizar ninja inexistente&quot;)&#10;    void deveLancarExcecaoAoTentarAtualizarNinjaInexistente() {&#10;        // Given: ninja não existe&#10;        when(ninjaRepository.findById(999)).thenReturn(Optional.empty());&#10;&#10;        // When/Then: deve lançar exceção&#10;        assertThatThrownBy(() -&gt; ninjaService.update(999, ninjaRequest))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Ninja não encontrado com ID: 999&quot;);&#10;&#10;        // Verificar que apenas findById foi chamado&#10;        verify(ninjaRepository, times(1)).findById(999);&#10;        verify(ninjaRepository, times(0)).save(any());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve deletar ninja existente com sucesso&quot;)&#10;    void deveDeletarNinjaExistenteComSucesso() {&#10;        // Given: ninja existe&#10;        when(ninjaRepository.existsById(1)).thenReturn(true);&#10;&#10;        // When: deletar ninja&#10;        ninjaService.deleteById(1);&#10;&#10;        // Then: deve chamar deleteById no repository&#10;        verify(ninjaRepository, times(1)).existsById(1);&#10;        verify(ninjaRepository, times(1)).deleteById(1);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar exceção ao tentar deletar ninja inexistente&quot;)&#10;    void deveLancarExcecaoAoTentarDeletarNinjaInexistente() {&#10;        // Given: ninja não existe&#10;        when(ninjaRepository.existsById(999)).thenReturn(false);&#10;&#10;        // When/Then: deve lançar exceção&#10;        assertThatThrownBy(() -&gt; ninjaService.deleteById(999))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Ninja não encontrado com ID: 999&quot;);&#10;&#10;        // Verificar que deleteById NÃO foi chamado&#10;        verify(ninjaRepository, times(1)).existsById(999);&#10;        verify(ninjaRepository, times(0)).deleteById(999);&#10;    }&#10;}&#10;```&#10;&#10;### 5.4) Entendendo as anotações de teste&#10;&#10;**@ExtendWith(MockitoExtension.class)**&#10;- Habilita o uso do Mockito para criar mocks&#10;- Não carrega o contexto Spring (teste mais rápido)&#10;&#10;**@Mock**&#10;- Cria um objeto &quot;falso&quot; (mock) da dependência&#10;- Permite controlar o comportamento do objeto&#10;&#10;**@InjectMocks**&#10;- Injeta os mocks automaticamente no objeto testado&#10;- Cria uma instância real do NinjaService com mocks injetados&#10;&#10;**@BeforeEach**&#10;- Executa antes de cada teste&#10;- Prepara dados que serão reutilizados&#10;&#10;### 5.5) Entendendo o Mockito&#10;&#10;**when().thenReturn()** - Define comportamento do mock:&#10;```java&#10;when(ninjaRepository.findById(1)).thenReturn(Optional.of(ninjaEntity));&#10;// Quando chamar findById(1), retorne Optional.of(ninjaEntity)&#10;```&#10;&#10;**verify()** - Verifica se método foi chamado:&#10;```java&#10;verify(ninjaRepository, times(1)).findById(1);&#10;// Verifica que findById(1) foi chamado exatamente 1 vez&#10;```&#10;&#10;**any()** - Aceita qualquer valor como parâmetro:&#10;```java&#10;verify(ninjaRepository).save(any(NinjaEntity.class));&#10;// Verifica que save foi chamado com qualquer NinjaEntity&#10;```&#10;&#10;### 5.6) Padrão AAA (Arrange-Act-Assert)&#10;&#10;Nossos testes seguem o padrão AAA:&#10;&#10;```java&#10;// Arrange (Given): Preparar mocks e dados&#10;when(ninjaRepository.findById(1)).thenReturn(Optional.of(ninjaEntity));&#10;&#10;// Act (When): Executar ação que queremos testar&#10;NinjaResponse resultado = ninjaService.findById(1);&#10;&#10;// Assert (Then): Verificar resultados e interações&#10;assertThat(resultado).isNotNull();&#10;verify(ninjaRepository).findById(1);&#10;```&#10;&#10;### 5.7) Executando os testes&#10;&#10;**No terminal:**&#10;```bash&#10;# Executa todos os testes&#10;./mvnw test&#10;&#10;# Executa apenas testes do Service&#10;./mvnw test -Dtest=NinjaServiceTest&#10;```&#10;&#10;### 5.8) O que cada teste valida&#10;&#10;1. **deveCriarNinjaComSucesso()** - Criação funcionando corretamente&#10;2. **deveBuscarNinjaPorIdExistenteComSucesso()** - Busca por ID válido&#10;3. **deveLancarExcecaoAoBuscarNinjaPorIdInexistente()** - Tratamento de ninja não encontrado&#10;4. **deveBuscarTodosOsNinjasComSucesso()** - Listagem completa&#10;5. **deveBuscarNinjasComFiltros()** - Busca com Example&#10;6. **deveAtualizarNinjaExistenteComSucesso()** - Atualização funcionando&#10;7. **deveLancarExcecaoAoTentarAtualizarNinjaInexistente()** - Atualização com ID inválido&#10;8. **deveDeletarNinjaExistenteComSucesso()** - Exclusão funcionando&#10;9. **deveLancarExcecaoAoTentarDeletarNinjaInexistente()** - Exclusão com ID inválido&#10;&#10;### 5.9) Benefícios dos testes com Mock&#10;&#10;✅ **Rápidos** - Não acessam banco de dados&#10;✅ **Isolados** - Testam apenas lógica do Service&#10;✅ **Confiáveis** - Controlam exatamente o comportamento das dependências&#10;✅ **Precisos** - Verificam interações específicas&#10;&#10;## Próximo passo&#10;Agora vamos criar o Controller, que vai expor os endpoints HTTP da nossa API. **[STEP 6 — Controller com Validações (Endpoints da API)](README_STEP_6.md)**" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>